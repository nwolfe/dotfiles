# -*- mode: sh -*-

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

export DOTFILES=$HOME/.dotfiles
export EDITOR=vim
export VISUAL=$EDITOR
export DEV_ROOT=$HOME/ws/puppet/
JAVA_HOME=$(/usr/libexec/java_home)
export JAVA_HOME
export EMACSDIR=$HOME/.emacs.d
export FZF_DEFAULT_COMMAND='rg --files --hidden'

# Disable shell-specific history files in ~/.bash_sessions/
# in favor of a global shared history file
export SHELL_SESSION_HISTORY=0

# Brighten the blue color of directories in ls output
export LSCOLORS=Exfxcxdxbxegedabagacad

export PATH=\
$HOME/bin:\
/usr/local/sbin:\
$PATH

alias path='echo -e ${PATH//:/\\n}'

# Tell me all your seacrest
[ -r ~/.seacrest/bashenv ] && . ~/.seacrest/bashenv

# Navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias cdd='cd $DOTFILES'

# cd <repo>
pl() {
    cd "$DEV_ROOT/$1" || return
}

# Verify destruction
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'

# List directory contents
# -h  Human-readable file sizes
# -G  Colored output
# -F  Append special character denoting file type
# -A  Show hidden entries, but hide . and ..
# -1  One entry per line
alias ls='ls -FG'
alias ll='ls -hl'
alias la='ls -A'

# Git
alias ga='git add'
alias gb='git branch'
alias gc='git commit'
alias gcm='git checkout master'
alias gco='git checkout'
alias gd='git diff'
alias gds='git diff --staged'
alias gl='git log'
alias gs='git status'

# Emacs
alias emacs-server='emacs --daemon'
alias emacs-server-kill='emacsclient -e "(save-buffers-kill-emacs)"'
alias e='emacsclient --no-wait'

# Miscellaneous
# alias remove-ds-stores='find . -name ".DS_Store" -type f -delete'
alias cat=bat
alias top=htop
alias vpn='curl https://artifactory.delivery.puppetlabs.net/artifactory/api/system/ping --connect-timeout 1 --silent --output /dev/null && echo CONNECTED || echo ERROR'

# NOTE the "function" is necessary for single-letter function names
function t() {
    timestamp=$(date "+%A, %B %e, %Y - %l:%M%p")
    sed -i '' "1s/.*/# $timestamp/" "$HOME"/TODO.md
    vim +"/^\n" +nohlsearch +startinsert "$HOME"/TODO.md
}

# Prints version of <repo> from ./pom.xml
pomd() {
    grep "$1" -A1 pom.xml | tail -1 | sed 's/.*<version>//' | sed 's/<\/version>//'
}

# Prints artifact version from [.|<repo>]/pom.xml
pomv() {
    if [ -z "$1" ]; then
        repo=.
    else
        repo="$DEV_ROOT/$1"
    fi
    xpath "$repo/pom.xml" "project/version/text()" 2>/dev/null
    echo
}

cheat() {
    where="$1"; shift
    IFS=+ curl "https://cheat.sh/$where $*"
}

_get_repos() {
    for repo in $(ls -d $DEV_ROOT/*/); do
        if [ -d $repo/.git ]; then
            basename $repo
        fi
    done
}

_repo_completion() {
    if [ "${#COMP_WORDS[@]}" != "2" ]; then
        return
    fi

    options=$(_get_repos)
    COMPREPLY=($(compgen -W "$options" "${COMP_WORDS[1]}"))
}

complete -F _repo_completion pl
complete -F _repo_completion pomd
complete -F _repo_completion pomv
complete -F _repo_completion dep
complete -F _repo_completion github

_get_pre_commit_hooks() {
    find $DOTFILES/git/hooks/pre-commit -type f -exec basename {} \;
}

_pre_commit_hook_completion() {
    if [ "${#COMP_WORDS[@]}" != "2" ]; then
        return
    fi

    options=$(_get_pre_commit_hooks)
    COMPREPLY=($(compgen -W "$options" "${COMP_WORDS[1]}"))
}

complete -F _pre_commit_hook_completion install-pre-commit-hook

_checkout_package_completion() {
    # Account for the required "-n" flag
    if [ "${#COMP_WORDS[@]}" != "3" ]; then
        return
    fi

    # File generated by list-pipelines-repos
    options=$(cat /tmp/distelli-repos)
    COMPREPLY=($(compgen -W "$options" "${COMP_WORDS[2]}"))
}

complete -F _checkout_package_completion checkout-package.py

_get_dr_subcommands() {
    # Find subcommands from source files.
    # Skip the root.go file because it's not actually a subcommand.
    find "$DOTFILES"/golang/nwolfe/dr/cmd -type f ! -name "root.go" -exec basename {} .go \;
}

_dr_completion() {
    # Prevents [tab][tab]... from repeatedly adding the completion
    if [ "${#COMP_WORDS[@]}" != "2" ]; then
        return
    fi

    options=$(_get_dr_subcommands)
    COMPREPLY=($(compgen -W "$options" "${COMP_WORDS[1]}"))
}

complete -F _dr_completion dr

complete -W "all brew" update

_cht_complete()
{
    local cur prev opts
    _get_comp_words_by_ref -n : cur

    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="$(curl -s cheat.sh/:list)"

    if [ ${COMP_CWORD} = 1 ]; then
          COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
          __ltrim_colon_completions "$cur"
    fi
    return 0
}

complete -F _cht_complete cheat

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# These commands are not useful to store in history so ignore them.
#
# Generally, commands that are 2 or 3 letters are not worth storing
# because it's just as easy to re-type them, such as the various g*
# aliases for git commands.
#
# Also ignore commands that are very broad and not contextual at all,
# such as clear/exit/top/history/update.
#
# NOTE many of these are actually aliases set elsewhere in .bashrc
HISTIGNORE=\
ls:la:ll:\
pl:cd:cdd:..:...:....:\
ga:gb:gc:gcm:gco:gd:gds:gl:gs:\
fg:jobs:bc:clear:exit:history:alias:\
top:htop:update:path:vpn:stretch\
e:t:vi:vim

# append to the history file, don't overwrite it
shopt -s histappend

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    # alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# Enable Bash 4 (via Homebrew) completion
if [ -f /usr/local/share/bash-completion/bash_completion ]; then
    . /usr/local/share/bash-completion/bash_completion
fi

# Enable bash-completion2
if [ -r /usr/local/etc/profile.d/bash_completion.sh ]; then
    . /usr/local/etc/profile.d/bash_completion.sh
fi

# Enable ENV variable tab completion
# See: https://askubuntu.com/questions/70750/how-to-get-bash-to-stop-escaping-during-tab-completion
shopt -s direxpand

# Notify me ASAP if my SSH agent has no keys
if ! ssh-add -l > /dev/null; then
    echo "NOTICE: No SSH keys added to agent"
fi
